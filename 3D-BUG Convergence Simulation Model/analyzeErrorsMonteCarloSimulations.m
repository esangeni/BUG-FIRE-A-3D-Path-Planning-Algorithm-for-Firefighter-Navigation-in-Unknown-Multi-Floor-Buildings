clear all; close all; clc;
% Analyze errors on Monte Carlo Simulation

%% Libraries
% Specifications Peter's Coke BUG2 Implementation:
% https://www.petercorke.com/RTB/r9/html/Bug2.html
currentFolder = pwd;
addpath(genpath('C:\Users\Eudald\Documents\Git Repos\PeterCork_PathPlanning_Lib\rtb'));
addpath(genpath('C:\Users\Eudald\Documents\Git Repos\PeterCork_PathPlanning_Lib\common'));
addpath(genpath('C:\Users\Eudald\Documents\Git Repos\PeterCork_PathPlanning_Lib\smtb'));
addpath(genpath([currentFolder, '\MAE_Occupancy_Map']));
addpath(genpath([currentFolder, '\lib\Plots']));
addpath(genpath([currentFolder, '\lib\Navigation']));

% Get the screen size
screenSize = get(0, 'ScreenSize');
% Calculate 90% of the screen width and height
width = round(screenSize(3) * 0.9);
height = round(screenSize(4) * 0.8);

% Calculate the left and bottom coordinates to center the figure
left = round((screenSize(3) - width) / 2);
bottom = round((screenSize(4) - height) / 2);

%% Import table
t = readtable('250iterResults_v170_d30_2025-02-24_16-28-25.xlsx');
% problemIterations = t(t.GoalReached == false & t.ExecutionTime ~= 120, :);
problemIterations = t(t.GoalReached == false & t.ExecutionTime == 120, :);


%% Import EG Map
tStart = tic;   
% Generate the Engineering Gateway 3D map
maps = generateEGMap3DBUG();
tEnd = toc(tStart);
disp("Time Elapsed Plotting EG Map: " + num2str(tEnd))

% Hold the current figure to allow overlaying additional plots
figureHandle = findobj('Type', 'Figure', 'Name', '3D Trajectory MAE UCI');
set(figureHandle, 'Position', [left, bottom, width, height]);
if isempty(figureHandle)
    error('The figure generated by generateEGMap3DBUG does not exist. Ensure the function has executed correctly.');
end

%% Compute & Display the 3D m-line
load('MAE_Occupancy_Map/EG-2Floor_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-2Floor_Hole1_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-2Floor_Hole2_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-2Floor_Hole3_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-3Floor_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-4Floor_indoor_polygon_MC_Simulation.mat');
% Apply translation to the third floor polygon
thirdFloorPolygon = EG_3Floor_indoor_polygon_MC_Simulation(:, [2, 1]);
thirdFloorPolygon(:, 1) = thirdFloorPolygon(:, 1) + 39;  % Add 36 to x-coordinates
% Apply translation to the third floor polygon
fourthFloorPolygon = EG_4Floor_indoor_polygon_MC_Simulation(:, [2, 1]);
fourthFloorPolygon(:, 1) = fourthFloorPolygon(:, 1) + 37;  % Add 36 to x-coordinates
% Swap x and y coordinates for all polygons
secondFloorPolygon = EG_2Floor_indoor_polygon_MC_Simulation(:, [2, 1]);
holes = {
    EG_2Floor_Hole1_indoor_polygon_MC_Simulation(:, [2, 1]),
    EG_2Floor_Hole2_indoor_polygon_MC_Simulation(:, [2, 1]),
    EG_2Floor_Hole3_indoor_polygon_MC_Simulation(:, [2, 1])
};
% Combine polygons into a cell array
polygons = {
    {0, secondFloorPolygon, holes},
    {100, thirdFloorPolygon},
    {200, fourthFloorPolygon}
};
colors = [1 0.4 0.4; 1 0.6 0.6; 1 0.8 0.8]; % Different shades of red for each floor

        
figure(figureHandle);
hold on;
for i = 1:length(polygons)
    floorHeight = polygons{i}{1};
    polygon = polygons{i}{2};
    
    % Create a slightly elevated plane for better visibility
    z = ones(size(polygon, 1), 1) * (floorHeight);
    
    % Plot the polygon as a filled area
    fill3(polygon(:,1), polygon(:,2), z, colors(i,:), 'FaceAlpha', 0.5);
    
    % Plot the polygon outline
    plot3(polygon(:,1), polygon(:,2), z, 'k-', 'LineWidth', 2);
    
    % Plot holes for 2nd floor
    if i == 1
        for j = 1:length(holes)
            hole = holes{j};
            z_hole = zeros(size(hole, 1), 1) + floorHeight +0.1;
            fill3(hole(:,1), hole(:,2), z_hole, 'w-', 'LineWidth', 3);
        end
    end
end

% Plot problematic start and goal points
for i = 1:size(problemIterations, 1)
    % Parse start point
    startStr = problemIterations.StartPoint{i};
    startPoint = str2num(startStr(2:end-1));
    
    % Parse goal point
    goalStr = problemIterations.GoalPoint{i};
    goalPoint = str2num(goalStr(2:end-1));
    
    % Plot start point
    plot3(startPoint(1), startPoint(2), startPoint(3), 'ko', 'MarkerSize', 8, 'MarkerFaceColor', 'k', 'DisplayName', sprintf('Problem Start %d', problemIterations.Iteration(i)));
    
    % Plot goal point
    plot3(goalPoint(1), goalPoint(2), goalPoint(3), 'ro', 'MarkerSize', 8, 'MarkerFaceColor', 'r', 'DisplayName', sprintf('Problem Goal %d', problemIterations.Iteration(i)));
    
    % Draw a line connecting start and goal
    plot3([startPoint(1), goalPoint(1)], [startPoint(2), goalPoint(2)], [startPoint(3), goalPoint(3)], 'r--', 'LineWidth', 2, 'DisplayName', sprintf('Problem Path %d', problemIterations.Iteration(i)));
end

% Update legend
h = findobj(gca, 'Type', 'Line', '-or', 'Type', 'Scatter');
legend(h([1:2, end-1:end]), 'Location', 'best');

% Adjust view for better visibility
view(3);

disp(problemIterations)

%% Case no errors are found
if isempty(problemIterations)
    % Initialize counters for each floor combination
    floor_combinations = {...
        '2nd-2nd', '3rd-3rd', '4th-4th', ...
        '2nd-3rd', '2nd-4th', ...
        '3rd-2nd', '3rd-4th', ...
        '4th-2nd', '4th-3rd'...
    };
    counts = zeros(1, length(floor_combinations));
    
%     % Function to determine floor from z-coordinate
%     getFloor = @(z) floor(z/100) + 2;  % Corrected floor calculation
    
    % Count occurrences of each floor combination
    for i = 1:size(t, 1)
        % Parse start point
        startStr = t.StartPoint{i};
        startPoint = str2num(startStr(2:end-1));
        
        % Parse goal point
        goalStr = t.GoalPoint{i};
        goalPoint = str2num(goalStr(2:end-1));
        
        % Determine start and goal floors
        startFloor = startPoint(3)/100 + 2; % (2nd, 3rd, 4th floor)
        goalFloor = goalPoint(3)/100 + 2; % (2nd, 3rd, 4th floor)
        
        % Increment appropriate counter
        if startFloor == goalFloor % cases: '2nd-2nd', '3rd-3rd', '4th-4th'
            counts(startFloor - 1) = counts(startFloor - 1) + 1;
        else
            if startFloor == 2 
                if goalFloor == 3
                    counts(4) = counts(4) + 1;
                elseif goalFloor == 4
                    counts(5) = counts(5) + 1;
                end
            elseif startFloor == 3
                if goalFloor == 2
                    counts(6) = counts(6) + 1;
                elseif goalFloor == 4
                    counts(7) = counts(7) + 1;
                end
            elseif startFloor == 4
                if goalFloor == 2
                    counts(8) = counts(8) + 1;
                elseif goalFloor == 3
                    counts(9) = counts(9) + 1;
                end
            end

        end
    end
    
    % Create bar plot
    figure;
    bar(counts);
    xlabel('Floor Combinations');
    ylabel('Number of Routes');
    title('Distribution of Routes Across Floor Combinations');
    xticks(1:length(floor_combinations));
    xticklabels(floor_combinations);
    xtickangle(45);
    
    % Add value labels on top of each bar
    for i = 1:length(counts)
        text(i, counts(i), num2str(counts(i)), 'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom');
    end
    
    % Calculate and display percentages
    total_routes = sum(counts);
    percentages = (counts / total_routes) * 100;
    
    disp('Distribution of routes:');
    for i = 1:length(floor_combinations)
        fprintf('%s: %d (%.2f%%)\n', floor_combinations{i}, counts(i), percentages(i));
    end
    
    % Display total number of routes
    fprintf('\nTotal number of routes: %d\n', total_routes);
end