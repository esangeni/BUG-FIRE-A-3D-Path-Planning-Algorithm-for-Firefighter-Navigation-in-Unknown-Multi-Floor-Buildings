clear all; close all; clc;
% Analyze errors on Monte Carlo Simulation

%% Libraries
% Specifications Peter's Coke BUG2 Implementation:
% https://www.petercorke.com/RTB/r9/html/Bug2.html
currentFolder = pwd;
addpath(genpath('C:\Users\Eudald\Documents\Git Repos\PeterCork_PathPlanning_Lib\rtb'));
addpath(genpath('C:\Users\Eudald\Documents\Git Repos\PeterCork_PathPlanning_Lib\common'));
addpath(genpath('C:\Users\Eudald\Documents\Git Repos\PeterCork_PathPlanning_Lib\smtb'));
addpath(genpath([currentFolder, '\MAE_Occupancy_Map']));
addpath(genpath([currentFolder, '\lib\Plots']));
addpath(genpath([currentFolder, '\lib\Navigation']));

% Get the screen size
screenSize = get(0, 'ScreenSize');
% Calculate 90% of the screen width and height
width = round(screenSize(3) * 0.9);
height = round(screenSize(4) * 0.8);

% Calculate the left and bottom coordinates to center the figure
left = round((screenSize(3) - width) / 2);
bottom = round((screenSize(4) - height) / 2);

%% Import table
t = readtable('250iterResults_v170_d10_2025-02-21_20-34-42.xlsx');
% problemIterations = t(t.GoalReached == false & t.ExecutionTime ~= 120, :);
problemIterations = t(t.GoalReached == false & t.ExecutionTime == 120, :);


%% Import EG Map
tStart = tic;   
% Generate the Engineering Gateway 3D map
maps = generateEGMap3DBUG();
tEnd = toc(tStart);
disp("Time Elapsed Plotting EG Map: " + num2str(tEnd))

% Hold the current figure to allow overlaying additional plots
figureHandle = findobj('Type', 'Figure', 'Name', '3D Trajectory MAE UCI');
set(figureHandle, 'Position', [left, bottom, width, height]);
if isempty(figureHandle)
    error('The figure generated by generateEGMap3DBUG does not exist. Ensure the function has executed correctly.');
end

%% Compute & Display the 3D m-line
load('MAE_Occupancy_Map/EG-2Floor_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-2Floor_Hole1_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-2Floor_Hole2_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-2Floor_Hole3_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-3Floor_indoor_polygon_MC_Simulation.mat');
load('MAE_Occupancy_Map/EG-4Floor_indoor_polygon_MC_Simulation.mat');
% Apply translation to the third floor polygon
thirdFloorPolygon = EG_3Floor_indoor_polygon_MC_Simulation(:, [2, 1]);
thirdFloorPolygon(:, 1) = thirdFloorPolygon(:, 1) + 39;  % Add 36 to x-coordinates
% Apply translation to the third floor polygon
fourthFloorPolygon = EG_4Floor_indoor_polygon_MC_Simulation(:, [2, 1]);
fourthFloorPolygon(:, 1) = fourthFloorPolygon(:, 1) + 37;  % Add 36 to x-coordinates
% Swap x and y coordinates for all polygons
secondFloorPolygon = EG_2Floor_indoor_polygon_MC_Simulation(:, [2, 1]);
holes = {
    EG_2Floor_Hole1_indoor_polygon_MC_Simulation(:, [2, 1]),
    EG_2Floor_Hole2_indoor_polygon_MC_Simulation(:, [2, 1]),
    EG_2Floor_Hole3_indoor_polygon_MC_Simulation(:, [2, 1])
};
% Combine polygons into a cell array
polygons = {
    {0, secondFloorPolygon, holes},
    {100, thirdFloorPolygon},
    {200, fourthFloorPolygon}
};
colors = [1 0.4 0.4; 1 0.6 0.6; 1 0.8 0.8]; % Different shades of red for each floor

        
figure(figureHandle);
hold on;
for i = 1:length(polygons)
    floorHeight = polygons{i}{1};
    polygon = polygons{i}{2};
    
    % Create a slightly elevated plane for better visibility
    z = ones(size(polygon, 1), 1) * (floorHeight);
    
    % Plot the polygon as a filled area
    fill3(polygon(:,1), polygon(:,2), z, colors(i,:), 'FaceAlpha', 0.5);
    
    % Plot the polygon outline
    plot3(polygon(:,1), polygon(:,2), z, 'k-', 'LineWidth', 2);
    
    % Plot holes for 2nd floor
    if i == 1
        for j = 1:length(holes)
            hole = holes{j};
            z_hole = zeros(size(hole, 1), 1) + floorHeight +0.1;
            fill3(hole(:,1), hole(:,2), z_hole, 'w-', 'LineWidth', 3);
        end
    end
end

% Plot problematic start and goal points
for i = 1:size(problemIterations, 1)
    % Parse start point
    startStr = problemIterations.StartPoint{i};
    startPoint = str2num(startStr(2:end-1));
    
    % Parse goal point
    goalStr = problemIterations.GoalPoint{i};
    goalPoint = str2num(goalStr(2:end-1));
    
    % Plot start point
    plot3(startPoint(1), startPoint(2), startPoint(3), 'ko', 'MarkerSize', 8, 'MarkerFaceColor', 'k', 'DisplayName', sprintf('Problem Start %d', problemIterations.Iteration(i)));
    
    % Plot goal point
    plot3(goalPoint(1), goalPoint(2), goalPoint(3), 'ro', 'MarkerSize', 8, 'MarkerFaceColor', 'r', 'DisplayName', sprintf('Problem Goal %d', problemIterations.Iteration(i)));
    
    % Draw a line connecting start and goal
    plot3([startPoint(1), goalPoint(1)], [startPoint(2), goalPoint(2)], [startPoint(3), goalPoint(3)], 'r--', 'LineWidth', 2, 'DisplayName', sprintf('Problem Path %d', problemIterations.Iteration(i)));
end

% Update legend
h = findobj(gca, 'Type', 'Line', '-or', 'Type', 'Scatter');
legend(h([1:2, end-1:end]), 'Location', 'best');

% Adjust view for better visibility
view(3);

disp(problemIterations)